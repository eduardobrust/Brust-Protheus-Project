#include "totvs.ch"
#include 'tlpp-core.th'
#include 'tlpp-rest.th'
#include "FWPrintSetup.ch"
#include "rptdef.ch"

//Definindo e usando o namespace para a classe
using namespace nGeraNotaC600Icf

/*/ iGeraNotaC600Icf
Main Interface de controle para geracao de nota fiscal para c600 do ICF
type Interface
version 12.1.33
author eduardo.brust
since 30/12/2022
/*/
Interface iGeraNotaC600Icf

//DEFINICAO DOS METODOS DA INTERFACE
PROTECTED METHOD New()                  as Object        	//responsavel por criar uma nova instancia do objeto da classe
PROTECTED METHOD Destroy(_oObj) 	    as Object           //responsavel por destruir a instancia do objeto da classe em memoria
PROTECTED METHOD mPrepEnv()			    as Logical  		//responsavel por preparar ambiente no protheus
PROTECTED METHOD mValidaFilial()	    as Logical          //responsavel por validar a filial logada no sistema para so permitir a filial da RioMais
PROTECTED METHOD mRetCodCli()			as Logical			//responsavel por retornar o codigo do cliente da filial logada no sistema
PROTECTED METHOD mBuscaNFGravada()	    as Logical			//responsavel por buscar se ja existe nota gravada para o periodo
PROTECTED METHOD mConsultaCT2()	        as Logical          //responsavel por retornar os dados da CT2 para geracao da nota fiscal
PROTECTED METHOD mRetUltNF()	        as Logical          //responsavel por retornar o ultimo numero da nota fiscal para a serie informada
PROTECTED METHOD mGeraNotaFiscal()	    as Logical          //responsavel por Gerar a Nota Fiscal dos dados retornarnados pela CT2

EndInterface


/*/{Protheus.doc} cGeraNotaC600Icf
Main class de controle para geracao de nota fiscal para c600 do ICF
@type class
@version 12.1.33
@author eduardo.brust
@since 30/12/2022
/*/
CLASS cGeraNotaC600Icf Implements iGeraNotaC600Icf

	//DEFINICAO DAS PROPRIEDADES DA CLASSE

	PUBLIC Data cTitulo		    	as character    //Define o titulo da rotina
	PUBLIC Data lExcluiNF	   		as logical		//Define se exclui ou não a nota fiscal do periodo informado
	PRIVATE Data dDataExec        	as Date         //Guarda a data que a rotina usara em todo fluxo do processo Data atual - 1 (mes anterior)
	PRIVATE Data cAnoMes		    as character    //Guarda o AnoMes da data
	PRIVATE Data cTrbQry		    as character	//guarda o alias da query para da CT2 que será usada em outros métodos.
	PRIVATE Data cFilRioMais	    as character    //Guarda a Filial permitida para a execucao da rotina. todas as demais nao poderam rodar
	PRIVATE	Data aContas  		    as array        //guardo as contas que farao parte do item da nota produto agua e encargos
	PRIVATE Data cDtIni		    	as character	//Guarda a data Inicial usada nas querys
	PRIVATE Data cDtFim		   		as character	//Guarda a data Fim usada nas querys
	PRIVATE Data cUltNF		   		as character	//Guarda o ultimo numero de nota gerado para a serie da nota passada
	PRIVATE Data cSerieNf	   		as character	//Guarda a serie da NF que sera usada para geracao da nota Fiscal
	PRIVATE Data cItem1	   			as character	//Guardo o codigo do produto do item 1 da nota
	PRIVATE Data cItem2	   			as character	//Guardo o codigo do produto do item 2 da nota
	PRIVATE Data cTes1	   			as character	//Guardo o codigo do tes do item 1 da nota
	PRIVATE Data cTes2	   			as character	//Guardo o codigo do tes do item 2 da nota
	PRIVATE Data nTotItem1	   		as numeric		//Guardo o valor total que sera usado no item 1 da nota
	PRIVATE Data nTotItem2	   		as numeric		//Guardo o valor total que sera usado no item 2 da nota
	PRIVATE Data cCliente	   		as character	//Guardo o codigo do cliente utilizado na nota
	PRIVATE Data cLojaCli	   		as character	//Guardo a loja do cliente utilizado na nota
	PRIVATE Data cNumNF		   		as character	//Guardo o Numero da nota ja gerada no periodo para exclusao

	//DEFINICAO DOS METODOS DA CLASSE
	PROTECTED METHOD New()                  as Object
	PROTECTED METHOD Destroy(_oObj)         as Object
	PROTECTED METHOD mPrepEnv()			    as Logical
	PROTECTED METHOD mValidaFilial()	    as Logical
	PROTECTED METHOD mRetCodCli()			as Logical
	PROTECTED METHOD mBuscaNFGravada()	    as Logical
	PROTECTED METHOD mConsultaCT2()	        as Logical
	PROTECTED METHOD mRetUltNF()	        as Logical
	PROTECTED METHOD mGeraNotaFiscal()	    as Logical	
ENDCLASS


/*/{Protheus.doc} nficfc600
Main function chamada pelo menu . Deve respeitar o legado do protheus de 8 caracteres devido chamada no menu
@type function
@version 12.1.33
@author eduardo.brust
@since 30/12/2022
/*/
User Function nficfc600()
	Local objNF         as object
	Local lRet   := .F. as Logical

	// Cria instancia da classe
	objNF := cGeraNotaC600Icf():New()

	//se conseguiu logar no protheus
	If objNF:mPrepEnv()

		FWMsgRun(, {||lRet :=	objNF:mValidaFilial() }, objNF:cTitulo, " Validando Filial ...")

		If lRet

			If lRet
				FWMsgRun(, {||lRet :=	objNF:mRetCodCli() }, objNF:cTitulo, " Buscando codigo do cliente da filial logada ...")
			EndIf

			If lRet
				FWMsgRun(, {||lRet :=	objNF:mBuscaNFGravada() }, objNF:cTitulo, " Verifica se já tem NF gravada no periodo ...")
			else
				FWAlertError("Falha ao tentar pegar codigo do cliente", objNF:cTitulo)
			EndIf

			If lRet
				lRet := FWAlertYesNo("Nota Fiscal ja gerada para o periodo atual. Deseja apagar e gerar novamente ?", objNF:cTitulo)
				If lRet
					objNF:lExcluiNF		:= .T.
					FWMsgRun(, {||lRet :=	objNF:mGeraNotaFiscal() }, objNF:cTitulo, " Excluindo nota fiscal do ICF no periodo ...")
					objNF:lExcluiNF		:= .F.
				EndIf
			else
				lRet   := .T.
			EndIf
		else
			FWAlertError("Filial Logada não permitida!", objNF:cTitulo)
		Endif

		If lRet
			FWMsgRun(, {||lRet :=	objNF:mConsultaCT2() }, objNF:cTitulo, " Consulta Contabilizacao do ICF no periodo ...")

			If lRet
				lRet := FWAlertYesNo(" Deseja Gerar a Nota para o período anterior a data atual ?", objNF:cTitulo)
			Else
				FWAlertError("Sem dados de contabilizacao para o mes anterior a data atual", objNF:cTitulo)
			EndIf
		endif
	Endif

	If lRet

		FWMsgRun(, {||lRet :=	objNF:mRetUltNF() }, objNF:cTitulo, " Retorna ultimo numero de nota para serie informada ...")

		If lRet
			FWMsgRun(, {||lRet :=	objNF:mGeraNotaFiscal() }, objNF:cTitulo, " Gera nota fiscal com dados da contabilizacao do ICF no periodo ...")
		else
			FWAlertError("Problema ao gerar a numeracao da nota!", objNF:cTitulo)
		endif

		If lRet
			FWAlertSuccess("Nota Gerada com Sucesso!", objNF:cTitulo)
		Else
			FWAlertError("Problema ao gerar Nota Fiscal!", objNF:cTitulo)
		Endif
	endif

	//Limpo instancia da classe em memória e saio do sistema
	objNF:Destroy(objNF)

Return


/*/{Protheus.doc} cGeraNotaC600Icf::New() as Object
criar uma nova instancia do objeto da classe
@type method
@version 12.1.33
@author eduardo.brust
@since 30/12/2022
@return variant,Instancia da classe
/*/
Method New() as Object CLASS cGeraNotaC600Icf
	::cTitulo		:= "Geracao NF para atender C600 com base na contabilizacao do ICF_PADRAO"
	::lExcluiNF		:= .F.
	::dDataExec		:= MonthSub(date(),1)
	::cAnoMes		:= SUBSTR(DTOS(::dDataExec),1,6)
	::cTrbQry		:=	""
	::cFilRioMais	:=	"320101"
	::aContas		:= {}
	::cDtIni		:= DTOS(FirstDay(::dDataExec))
	::cDtFim		:= DTOS(LastDate(::dDataExec))
	::cSerieNf		:= "032"
	::cUltNF		:= ""
	::cItem1		:= "9099700"
	::cItem2		:= "9099701"
	::cTes1			:= "599"
	::cTes2			:= "597"
	::nTotItem1		:= 0
	::nTotItem2		:= 0
	::cCliente		:= "728007"  //pegar de acordo com o cadastro de empresa
	::cLojaCli		:= "01"		//pegar de acordo com o cadastro de empresa
	::cNumNF		:= ""

Return Self


/*/{Protheus.doc} cGeraNotaC600Icf::Destroy(_oObj as Object ) as Object
destruir a instancia do objeto da classe em memoria
@type method
@version 12.1.33
@author eduardo.brust
@since 30/12/2022
@return variant,Instancia da classe
/*/
Method Destroy(_oObj as Object ) as Object CLASS cGeraNotaC600Icf

	FreeObj(_oObj)

	If IsBlind()
		RpcClearEnv()
	EndIf

Return Self


/*/{Protheus.doc} cGeraNotaC600Icf::mPrepEnv() as Logical
preparar ambiente no protheus
@type method
@version 12.1.33
@author eduardo.brust
@since 02/01/2023
@return logical, .t. or .f.
/*/
Method mPrepEnv() as Logical CLASS cGeraNotaC600Icf
	Local _cfil		:= "320101" as character
	Local aTables 	:= {"CT2"}  as Array
	Local _cModulo	:= "CTB"    as character
	Local lRet		:= .T.      as Logical

	IF ISBLIND() .OR. GetRemoteType() == -1 .OR. !TCIsConnected()
		RpcClearEnv()
		RpcSetType(3)
		lRet := RpcSetEnv( "00", _cfil, , ,_cModulo,ProcName(),aTables )
	ENDIF

Return lRet


/*/{Protheus.doc} cGeraNotaC600Icf::mValidaFilial() as Logical
validar a filial logada no sistema para so permitir a filial da RioMais
@type method
@version 12.1.33
@author eduardo.brust
@since 02/01/2023
@return logical, .t. or .f.
/*/
Method mValidaFilial() as Logical CLASS cGeraNotaC600Icf
	Local lRet	:= .F. as logical

	//VALIDO SE A FILIAL LOGADA É PERMITIDA PARA PROCESSAMENTO
	IF CFILANT == ::cFilRioMais
		lRet	:= .T.
	ENDIF

	SLEEP(3000)

Return lRet

/*/{Protheus.doc} cGeraNotaC600Icf::mBuscaNFGravada() as Logical
validar se ja existem notas gravadas no mes da geracao
@type method
@version 12.1.33
@author eduardo.brust
@since 02/01/2023
@return logical, .t. or .f.
/*/
Method mBuscaNFGravada() as Logical CLASS cGeraNotaC600Icf
	Local lRet		:= .F.	as logical
	Local cQuery	:= ""	as character
	Local cNfTrab	:= ""	as character

	//VERIFICO SE EXISTEM DOCUMENTOS GERADOS PARA O MES DE GERACAO DA NOTA
	cQuery := " SELECT DISTINCT F2_DOC,F2_SERIE,F2_CLIENTE,F2_LOJA " 	+CRLF
	cQuery += " FROM  " + RetSqlName("SF2") + " SF2 " 		 	+CRLF
	cQuery += " WHERE SF2.D_E_L_E_T_ = ' ' " 				 	+CRLF
	cQuery += " AND F2_FILIAL = '" + FWxFilial("SF2")  + "'" 	+CRLF
	cQuery += " AND F2_SERIE = '" + ::cSerieNf + "'" 	     	+CRLF
	cQuery += " AND F2_EMISSAO BETWEEN '" + ::cDtIni + "' AND '" 	+ ::cDtFim + "'" +CRLF

	cNfTrab := MpSysOpenQuery(cQuery)

	//verifico se retornou algum registro
	IF (cNfTrab)->(!Eof())

		::cNumNF 	:= (cNfTrab)->F2_DOC
		::cSerieNf	:= (cNfTrab)->F2_SERIE
		::cCliente	:= (cNfTrab)->F2_CLIENTE
		::cLojaCli	:= (cNfTrab)->F2_LOJA
		IF !EMPTY(::cNumNF)
			lRet	:= .T.
		ENDIF

	endif

	//FECHO A AREA ABERTA PELA QUERY
	If Select(cNfTrab) > 0 .AND. !EMPTY(cNfTrab)
		(cNfTrab)->(DbCloseArea())
		cNfTrab	:= ""
	endif

	SLEEP(3000)

Return lRet


/*/{Protheus.doc} cGeraNotaC600Icf::mRetUltNF() as Logical
retornar o ultimo numero da nota fiscal para a serie informada
@type method
@version 12.1.33
@author eduardo.brust
@since 02/01/2023
@return logical, .t. or .f.
/*/
Method mRetUltNF() as Logical CLASS cGeraNotaC600Icf
	Local lRet		:= .T.	as logical
	Local cQuery	:= ""	as character
	Local cNfTrab	:= ""	as character

	//VERIFICO O ULTIMO DOCUMENTO VALIDO PARA A SERIE INFORMADA
	cQuery := " SELECT MAX(F2_DOC) F2_DOC "	 					+CRLF
	cQuery += " FROM  " + RetSqlName("SF2") + " SF2 " 		 	+CRLF
	cQuery += " WHERE SF2.D_E_L_E_T_ = ' ' " 				 	+CRLF
	cQuery += " AND F2_FILIAL = '" + FWxFilial("SF2")  + "'" 	+CRLF
	cQuery += " AND F2_SERIE = '" + ::cSerieNf + "'" 	     	+CRLF

	cNfTrab := MpSysOpenQuery(cQuery)

	//verifico se retornou algum registro
	IF (cNfTrab)->(!Eof())
		IF !EMPTY((cNfTrab)->F2_DOC)
			::cUltNF := (cNfTrab)->F2_DOC
		ENDIF
	endif

	//FECHO A AREA ABERTA PELA QUERY
	If Select(cNfTrab) > 0 .AND. !EMPTY(cNfTrab)
		(cNfTrab)->(DbCloseArea())
		cNfTrab	:= ""
	endif

	SLEEP(3000)

Return lRet


/*/{Protheus.doc} cGeraNotaC600Icf::mConsultaCT2() as Logical
retornar os dados da CT2 para geracao da nota fiscal
@type method
@version 12.1.33
@author eduardo.brust
@since 02/01/2023
@return logical, .t. or .f.
/*/
Method mConsultaCT2() as Logical CLASS cGeraNotaC600Icf
	Local I			:= 0 	as numeric
	Local lRet		:= .F.	as logical
	Local cQuery	:= ""	as character
	Local cCT2Trab	:= ""	as character
	Local cContas	:= ""	as character  	//todas as contas
	Local cConta1	:= ""	as character	//contas que vao para o item 1 da nota
	Local cConta2	:= ""	as character	//contas que vao para o item 2 da nota
	Local cWhere	:= ""	as character	//ADD ALGUNS FILTROS NA QUERY
	Local cContAux	:= ""	as character	//facilita tratamento das contas
	Local nI1Cred	:= 0	as numeric
	Local nI1Deb	:= 0	as numeric
	Local nI2Cred	:= 0	as numeric
	Local nI2Deb	:= 0	as numeric


	//PEGO AS CONTAS QUE SERÃO PROCESSADAS
	::aContas	:= StrTokArr2(GetNewPar("MV_XCONICF", "|1;31101006|1;31101007|2;32102013|"), "|")

	//TRATAMENTO PARA LEITURA DE PARAMETRO DE NAO CONTABILIZACAO DE ALGUNS RELATORIOS DA TABELA INTERMEDIARIA CONTABIL
	FOR I:=1 TO LEN(::aContas)
		cContAux	:=  ::aContas[I]
		cContas	+= "'" +  SUBSTR(ALLTRIM(cContAux),3,LEN(ALLTRIM(cContAux))-2) + "',"

		if substr(cContAux,1,1) == "1"
			cConta1 += SUBSTR(ALLTRIM(cContAux),3,LEN(ALLTRIM(cContAux))-2) + "|"
		else
			cConta2 += SUBSTR(ALLTRIM(cContAux),3,LEN(ALLTRIM(cContAux))-2) + "|"
		endif
	NEXT

	IF !EMPTY(cContas)

		cContas := SUBSTR(ALLTRIM(cContas),1,LEN(ALLTRIM(cContas))-1)

		cWhere  += " AND ( CT2_CREDIT IN( " + cContas + ")" +CRLF
		cWhere  += " OR  CT2_DEBITO IN( " + cContas + "))" +CRLF
	ENDIF

	//PEGO OS DADOS DA CONTABILIZACAO DO MES QUE SERA GERADA A NOTA
	cQuery := " SELECT CT2_LOTE,CT2_DATA,CT2_DEBITO,CT2_CREDIT,SUM(CT2_VALOR) TOTAL_CONTA "	 +CRLF
	cQuery += " FROM  " + RetSqlName("CT2") + " CT2 " 		 	+CRLF
	cQuery += " WHERE CT2.D_E_L_E_T_ = ' ' " 				 	+CRLF
	cQuery += " AND CT2_FILIAL = '" + FWxFilial("CT2")  + "'" 	+CRLF
	cQuery += cWhere				 							+CRLF
	cQuery += " AND CT2_DATA BETWEEN '" + ::cDtIni + "' AND '" 	+ ::cDtFim + "'" +CRLF
	cQuery += " GROUP BY CT2_LOTE,CT2_DATA,CT2_DEBITO,CT2_CREDIT " 	    		 +CRLF
	cQuery += " ORDER BY CT2_LOTE,CT2_DATA,CT2_DEBITO " 	    		 		 +CRLF

	cCT2Trab := MpSysOpenQuery(cQuery)

	//verifico se retornou algum registro
	While (cCT2Trab)->(!Eof())

		//SOMO OS VALORES DE CREDITO PARA CONTAS DO ITEM1 DA NOTA
		IF ALLTRIM((cCT2Trab)->CT2_CREDIT) $ cConta1
			nI1Cred += 	(cCT2Trab)->TOTAL_CONTA
		ENDIF

		//SOMO OS VALORES DE CREDITO PARA CONTAS DO ITEM2 DA NOTA
		IF ALLTRIM((cCT2Trab)->CT2_CREDIT) $ cConta2
			nI2Cred += 	(cCT2Trab)->TOTAL_CONTA
		ENDIF

		//SOMO OS VALORES DE DEBITO PARA CONTAS DO ITEM1 DA NOTA
		IF ALLTRIM((cCT2Trab)->CT2_DEBITO) $ cConta1
			nI1Deb += 	(cCT2Trab)->TOTAL_CONTA
		ENDIF

		//SOMO OS VALORES DE DEBITO PARA CONTAS DO ITEM2 DA NOTA
		IF ALLTRIM((cCT2Trab)->CT2_DEBITO) $ cConta2
			nI2Deb += 	(cCT2Trab)->TOTAL_CONTA
		ENDIF

		(cCT2Trab)->(DbSkip())
	EndDo

	//DEFINO O VALOR TOTAL DE CADA ITEM DA NOTA DE ACORDO COM A OPERACAO DE CREDITOS - DEBITOS
	::nTotItem1 := 0
	::nTotItem2 := 0
	::nTotItem1 := nI1Cred - nI1Deb
	::nTotItem2 := nI2Cred - nI2Deb

	//RETORNO VERDADEIRO SE OS ITENS DA NOTA FOREM MAIOR QUE ZERO
	IF ::nTotItem1 > 0 .AND. ::nTotItem2 > 0
		lRet := .T.
	ENDIF

	//FECHO A AREA ABERTA PELA QUERY
	If Select(cCT2Trab) > 0 .AND. !EMPTY(cCT2Trab)
		(cCT2Trab)->(DbCloseArea())
		cCT2Trab	:= ""
	endif

	SLEEP(3000)

Return lRet


/*/{Protheus.doc} cGeraNotaC600Icf::mGeraNotaFiscal() as Logical
Gerar a Nota Fiscal dos dados retornarnados pela CT2
@type method
@version 12.1.33
@author eduardo.brust
@since 02/01/2023
@return logical, .t. or .f.
/*/
Method mGeraNotaFiscal() as Logical CLASS cGeraNotaC600Icf
	Local	aCabec		:= {} 					as array
	Local 	aLinha		:= {} 					as array
	Local 	aItens		:= {} 					as array
	Local	nTamDoc		:= TamSX3("F2_DOC")[1]	as numeric
	Local	nTamD2I		:= TamSX3("D2_ITEM")[1]	as numeric
	Local	cItem		:= ""	as character
	Local	lRet		:= .T.					as Logical
	Local	nOper		:= 3					as numeric  //default inclusao

	//verifico se retornou algum registro
	IF !EMPTY(::cUltNF)
		::cUltNF := Soma1(::cUltNF)
	else
		::cUltNF :=  StrZero(1,nTamDoc)
	endif

	//se operacao for de exclusao ajusto a numeracao da nota para a retornarda na query
	IF ::lExcluiNF
		::cUltNF	:= ::cNumNF
		nOper		:= 5 //exclusao
	ENDIF

	aadd(aCabec,{"F2_TIPO"   ,"N",Nil})
	aadd(aCabec,{"F2_FORMUL" ," ",Nil})
	aadd(aCabec,{"F2_DOC"    ,::cUltNF,Nil})
	aadd(aCabec,{"F2_SERIE"  ,::cSerieNf,Nil})
	aadd(aCabec,{"F2_EMISSAO",STOD(::cDtFim),Nil})
	aadd(aCabec,{"F2_CLIENTE",Padr(::cCliente,Len(::cCliente)),Nil})
	aadd(aCabec,{"F2_LOJA"   ,Padr(::cLojaCli,Len(::cLojaCli)),Nil})
	aadd(aCabec,{"F2_ESPECIE","NFFA",Nil})
	aadd(aCabec,{"F2_DESCONT",0,Nil})
	aadd(aCabec,{"F2_FRETE",0,Nil})
	aadd(aCabec,{"F2_SEGURO",0,Nil})
	aadd(aCabec,{"F2_DESPESA",0,Nil})
	aadd(aCabec,{"F2_DTLANC",STOD(::cDtFim),.T.})


	cItem	:= StrZero(0,nTamD2I)
	cItem	:= SOMA1(cItem)

	//ITEM PRODUTO AGUA
	aLinha := {}
	aadd(aLinha,{"D2_COD"  ,::cItem1,Nil})
	aadd(aLinha,{"D2_ITEM" ,cItem,Nil})
	aadd(aLinha,{"D2_QUANT",1,Nil})
	aadd(aLinha,{"D2_PRCVEN",::nTotItem1,Nil})
	aadd(aLinha,{"D2_TOTAL",::nTotItem1,Nil})
	aadd(aLinha,{"D2_TES",::cTes1,Nil})
	aadd(aItens,aLinha)

	cItem	:= SOMA1(cItem)

	//ITEM ENCARGOS FINANCEIROS
	aLinha := {}
	aadd(aLinha,{"D2_COD"  ,::cItem2,Nil})
	aadd(aLinha,{"D2_ITEM" ,cItem,Nil})
	aadd(aLinha,{"D2_QUANT",1,Nil})
	aadd(aLinha,{"D2_PRCVEN",::nTotItem2,Nil})
	aadd(aLinha,{"D2_TOTAL",::nTotItem2,Nil})
	aadd(aLinha,{"D2_TES",::cTes2,Nil})
	aadd(aItens,aLinha)

	lMsErroAuto := .F.

	//GARANTO QUE AS 3 TABELAS USADAS PARA A NUMERACAO DO MV_DOCSEQ ESTÃO ABERTAS
	If Select('SD1') <= 0
		dbSelectArea('SD1')
	EndIf
	If Select('SD2') <= 0
		dbSelectArea('SD2')
	EndIf
	If Select('SD3') <= 0
		dbSelectArea('SD3')
	EndIf

	Begin Transaction

		//RODO O EXECAUTO
		MATA920(aCabec,aItens,nOper)

		if lMsErroAuto
			DisarmTransaction()
			lRet	:= .F.
			mostraerro()
		endif

	End Transaction

	SLEEP(1000)

Return lRet

/*/{Protheus.doc} cGeraNotaC600Icf::mRetCodCli() as Logical
retornar o codigo do cliente da filial logada no sistema
@type method
@version 12.1.33
@author eduardo.brust
@since 02/01/2023
@return logical, .t. or .f.
/*/
Method mRetCodCli() as Logical CLASS cGeraNotaC600Icf
	Local	lRet		:= .F.	as Logical
	Local	_cTrb		:= ""	as character
	Local	_cQuery		:= ""	as character
	Local	_aInfEmp	:= {}	as array
	Local	_cCnpj		:= {}	as character

	_aInfEmp	:= FWSM0Util():GetSM0DAta(cEmpAnt, cFilAnt, {"M0_CGC"})
	_cCnpj      := _aInfEmp[1][2]

	_cQuery := " 	SELECT A1_COD,A1_LOJA "                     			+ CRLF
	_cQuery += "    FROM " + RetSqlName("SA1") + " SA1 "                  	+ CRLF
	_cQuery += "    WHERE D_E_L_E_T_ = ' '"                           		+ CRLF
	_cQuery += "      AND A1_FILIAL  = '" + FWxFilial("SA1") + "'"    		+ CRLF
	_cQuery += "      AND A1_CGC = '" + _cCnpj + "' "              			+ CRLF
	_cQuery += "      AND A1_MSBLQL = '2' "                           		+ CRLF

	_cTrb   := MpSysOpenQuery(_cQuery)

	//verifico se retornou algum registro
	IF (_cTrb)->(!Eof())
		::cCliente	:= ALLTRIM((_cTrb)->A1_COD)
		::cLojaCli	:= ALLTRIM((_cTrb)->A1_LOJA)
		lRet		:= .T.
	else
		::cCliente	:= ""
		::cLojaCli	:= ""
	endif

	//FECHO A AREA ABERTA PELA QUERY
	If Select(_cTrb) > 0 .AND. !EMPTY(_cTrb)
		(_cTrb)->(DbCloseArea())
		_cTrb	:= ""
	endif

Return lRet

