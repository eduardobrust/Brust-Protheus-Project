#include 'tlpp-core.th'
#include 'tlpp-rest.th'
#include "msobject.ch"
#include "totvs.ch"

/*
	EDUARDO BRUST - HOMOLOGADO NA RELEASE 12.1.2310
	Classe para ler dados de cruzamento de rotinas x empresas de uma tabela(ROTINA_EMPRESA) e devolver um JSON com os dados filtrados pela CFUNCTION.

	Para instanciar a classe siga este exemplo:
	oEmpresas   := nGab.cFunctionCompany():New()  //objeto := namespace.classe():construtor()
    oEmpresas   := oEmpresas:GETConsultaFunctionCompany("FSTARTINOVA",.T.,"320101","S","RIOMAIS") 
	FSTARTINOVA = CFUNCTION A SER PESQUISADA
	.T. para todas as filiais da COMPANY; .F. somente a matriz
	320101 = COMPANY A SER PESQUISADA
	S = INDICA SOMENTE REGISTROS ATIVOS ; N = INDICA REGISTROS INATIVOS ; * = INDICA TODOS OS REGISTROS;
	TODOS OS PARAMETROS SÃO OPCIONAIS FAZENDO COM QUE O JSON RETORNADO SEJA COMPLETO OU FILTRADO CONFORME NECESSIDADE
	RIOMAIS = SIGLA ATRELADA A COMPANY

	ESTRUTURA DO JSON DE RETORNO
	{
  "empresas": [
    {
      "cFunction": "FSTARTINOVA",
      "codigoReduzido": "33",
      "codigo": "330101",
      "sigla": "CAIZ",
      "descricao": "",
      "cnpj": "",
      "ativo": "N"
    }
  ]
}
*/

//Definindo o namespace para a classe
namespace nGab

/*/ iFunctionCompany
definição de um contrato que uma classe deve implementar
type Interface
@version 12.1.2310
@author eduardo.brust
@since 28/10/2023
/*/
Interface iFunctionCompany

public method GETConsultaFunctionCompany(cFunction as Character,lFullEmp as Logical,cCompany as Character,cAtivo as Character,cSigla as Character) as json

EndInterface


/*/ cFunctionCompany
Classe que implementa a interface iFunctionCompany para consultar as empresas que uma determinada CFUNCTION pode rodar.
@type classe
@version 12.1.2310
@author eduardo.brust
@since 28/10/2023
/*/
class cFunctionCompany Implements iFunctionCompany

	public method New() as object

	public method GETConsultaFunctionCompany(cFunction as Character,lFullEmp as Logical,cCompany as Character,cAtivo as Character,cSigla as Character) as json
endclass


/*/{Protheus.doc} cFunctionCompany::new() as object
Metodo construtor
@type method
@version 12.1.2310
@author Eduardo Brust
@since 28/10/2023
return Self, retorna um objeto
/*/
method new() as object class cFunctionCompany

return Self


/*/{Protheus.doc} cFunctionCompany::GETConsultaFunctionCompany(cFunction as Character,lFullEmp as Logical,cCompany as Character,cAtivo as Character,cSigla as Character) as json
Consulta as empresas que uma determinada CFUNCTION pode rodar. passando o parametro se busca todas as filiais ou somente a matriz.
@type method
@version 12.1.2310
@author Eduardo Brust
@since 28/10/2023
@return json, retorna um objeto json
/*/
method GETConsultaFunctionCompany(cFunction as Character,lFullEmp as Logical,cCompany as Character,cAtivo as Character,cSigla as Character) as json class cFunctionCompany
	Local _cQry 	:= "" 	as Character
	Local cTrb1				as Character
	Local cHeader	:= ''	as Character
	Local cItens	:= ''	as Character
	Local cTrailer	:= ''	as Character
	Local cRetorno	:= ''	as Character
	Local jRetorno	 		as json
	Local vRet				as Variant

	//protecao de erro
	DEFAULT cFunction 	:= ''
	DEFAULT cCompany 	:= ''
	DEFAULT lFullEmp 	:= .T.
	DEFAULT cAtivo 		:= ''
	DEFAULT cSigla		:= ''

	//monto o json padrão
	cHeader		:= '{
	cHeader		+= '"empresas":['

	//cItens --montado na query

	cTrailer	+= ']
	cTrailer	+= '}'

	_cQry += " SELECT CFUNCTION,COMPANY,SIGLA,M0_NOMECOM,M0_CGC,ATIVO 				" +CRLF
	_cQry += " FROM ROTINA_EMPRESA                                 				" +CRLF
	_cQry += " LEFT JOIN SYS_COMPANY                               				" +CRLF
	_cQry += " ON D_E_L_E_T_ = ' '                                 				" +CRLF
	_cQry += " AND M0_CODIGO = '" + CEMPANT + "'                   				" +CRLF
	_cQry += " AND SUBSTR(M0_CODFIL,1,6) = COMPANY                 				" +CRLF

	_cQry += " WHERE COMPANY <> ' ' "  										  	  +CRLF

	IF !EMPTY(cFunction)
		_cQry += " AND UPPER(TRIM(CFUNCTION)) = '" + UPPER(ALLTRIM(cFunction)) + "'"    +CRLF
	ENDIF

	IF !EMPTY(cCompany)
		_cQry += " AND TRIM(COMPANY) = '" + ALLTRIM(cCompany) + "'"    			  +CRLF
	ENDIF

	IF !EMPTY(cAtivo) .AND. ALLTRIM(cAtivo) <> '*'
		_cQry += " AND ATIVO = '" + UPPER(ALLTRIM(cAtivo)) + "'"    			+CRLF
	ENDIF

	If !lFullEmp
		_cQry += " AND SUBSTR(COMPANY,5,2) = '01'                      			" +CRLF  //PEGO SOMENTE A MATRIZ
	Endif

	IF !EMPTY(cSigla)
		_cQry += " AND UPPER(TRIM(SIGLA)) = '" + UPPER(ALLTRIM(cSigla)) + "'"    +CRLF
	ENDIF

	_cQry += " ORDER BY 1,2                                          			" +CRLF

	cTrb1 := MpSysOpenQuery(_cQry)

	While (cTrb1)->(!Eof())

		cItens += ' { '
		cItens += ' "cfunction" : "' + AllTrim((cTrb1)->CFUNCTION) + '", '
		cItens += ' "codigoReduzido" : "' + SUBSTR(AllTrim((cTrb1)->COMPANY),1,2) + '", '
		cItens += ' "codigo" : "' + AllTrim((cTrb1)->COMPANY) + '", '
		cItens += ' "sigla" : "' + AllTrim((cTrb1)->SIGLA) + '", '
		cItens += ' "descricao" : "' + AllTrim((cTrb1)->M0_NOMECOM) + '", '
		cItens += ' "cnpj" : "' + AllTrim((cTrb1)->M0_CGC) + '",'
		cItens += ' "ativo" : "' + AllTrim((cTrb1)->ATIVO) + '"'
		cItens += ' },'

		(cTrb1)->(dbSkip())
	End

	//FECHO A AREA ABERTA PELA QUERY
	If Select(cTrb1) > 0 .AND. !EMPTY(cTrb1)
		(cTrb1)->(DbCloseArea())
		cTrb1	:= ""
	endif

	// Remove a vírgula do último item
	cItens := SUBSTR(cItens,1,LEN(cItens)-1)

	// Monto string formato json
	cRetorno := cHeader + cItens + cTrailer

	//transformo string em objeto json para o retorno do metodo
	jRetorno := JsonObject():New()
	vRet := jRetorno:FromJson(cRetorno)

return jRetorno
