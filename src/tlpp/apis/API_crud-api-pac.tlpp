#include 'tlpp-core.th'
#include 'tlpp-rest.th'
#include "msobject.ch"
#include "totvs.ch"

/*
	EDUARDO BRUST - HOMOLOGADO NA RELEASE 12.1.2310
	Essa API é uma implementação de um CRUD (Create, Read, Update, Delete) para a tabela PAC (Processo x Usuário) no sistema Protheus da TOTVS. 
	A API é destinada a ser utilizada na integração Protheus x Orquestra
*/

//Definindo  o namespace para a classe
namespace nApiGab

/*/ iCrudPAC
Main Interface de controle
type Interface
@version 12.1.2310
@author eduardo.brust
@since 12/10/2023
/*/
Interface iCrudPAC

public method GETcCrudPAC()
public method PostcCrudPAC()
public method PutcCrudPAC()
public method PatchcCrudPAC()
public method DeletecCrudPAC()
EndInterface

/*/ cCrudPAC
Main class para controle do CRUD
@type classe
@version 12.1.2310
@author eduardo.brust
@since 12/10/2023
/*/
class cCrudPAC Implements iCrudPAC

	private data cTOKEN 	as Character
	private data cData		as Character	//usado para testar o retorno do metodo
	private data jPath		as json
	private data jBody		as json
	Private data cMenRet	as variant		//guardo a mensagem de retorno da api
	Private data jRetorno	as json		    //monto o json de retorno da api
	Private data dDataExec	as date         //usado para controlar as datas ao longo da rotina e não precisar alterar em todas as partes do código


	public method New() as object

	//annotation deve ficar na implementação do metódo da classe e não da interface.
	@Get(endpoint="tlpp/orquestra/v1/cCrudPAC",description="Busca Acesso na PAC")  
	public method GETcCrudPAC() as json

	@Post(endpoint="tlpp/orquestra/v1/cCrudPAC",description="Grava Acesso na PAC")
	public method PostcCrudPAC() as json

	@Put(endpoint="tlpp/orquestra/v1/cCrudPAC",description="Altera Acesso na PAC")
	public method PutcCrudPAC() as json

	@Delete(endpoint="tlpp/orquestra/v1/cCrudPAC",description="Deleta Acesso na PAC")
	public method DeletecCrudPAC() as json

	@Patch(endpoint="tlpp/orquestra/v1/cCrudPAC/:codigo",description="Altera Acesso na PAC")
	public method PatchcCrudPAC() as json

	protected method ValidaQueryString(cPacFil as Character,cPacUsu as Character,cPacCC as Character,cPacProcesso as Character) as Logical
	protected method ConsultaPAC(cPacFil as Character,cPacUsu as Character,cPacCC as Character,cPacProcesso as Character) as json
	protected method ChavePAC(cPacFil as Character,cPacUsu as Character,cPacCC as Character,cPacProcesso as Character) as Logical

	protected method VarreJson(cmetodo as Character)	as logical
	protected method ConsultaCentroCusto(cPacFil as Character,cPacCC as Character) as Character
	protected method GravaPAC(jGravaItem as json)	as logical
	protected method AtualizaPAC(cmetodo as Character,jGravaItem as json)	as logical


endclass


/*/{Protheus.doc} cCrudPAC::new() as object
Metodo construtor
@type method
@version 12.1.2310
@author Eduardo Brust
@since 12/10/2023
return Self, retorna um objeto
/*/
method new() as object class cCrudPAC
	::cTOKEN	:= ''
	::cData 	:= ''
	::jPath 	:= Nil
	::jBody 	:= Nil
	::cMenRet	:= ''
	::jRetorno	:= Nil
	::dDataExec	:= dDatabase
return Self


/*/{Protheus.doc} cCrudPAC::GETcCrudPAC() as json
Metodo Get
@type method
@version 12.1.2310
@author Eduardo Brust
@since 12/10/2023
@return variant, return_um objeto
/*/
method GETcCrudPAC() as json class cCrudPAC
	Local lRet			as logical
	Local cPacFil		as Character
	Local cPacUsu		as Character
	Local cPacCC		as Character
	Local cPacProcesso	as Character
	Local cauxMenRet	as variant

	::cMenRet	:= ""
	::jRetorno	:= ::cMenRet

	::jPath := oRest:getQueryRequest()
	if ( ::jPath <> Nil )

		::cTOKEN := ::jPath[ 'token' ]
		if ( valtype(::cTOKEN) == 'U' )
			::cTOKEN := ''
		endif

		cPacFil := ::jPath[ 'pacfil' ]
		if ( valtype(cPacFil) == 'U' )
			cPacFil := ''
		endif

		cPacUsu := ::jPath[ 'pacusu' ]
		if ( valtype(cPacUsu) == 'U' )
			cPacUsu := ''
		endif

		cPacCC := ::jPath[ 'paccc' ]
		if ( valtype(cPacCC) == 'U' )
			cPacCC := ''
		endif

		cPacProcesso := ::jPath[ 'pacprocesso' ]
		if ( valtype(cPacProcesso) == 'U' )
			cPacProcesso := ''
		endif

	endif

	lRet := ::ValidaQueryString(cPacFil,cPacUsu,cPacCC,cPacProcesso)

	if lRet
		// Chamada do método para consulta PAC
		::jRetorno := ::ConsultaPAC(cPacFil,cPacUsu,cPacCC,cPacProcesso)
	ELSE
		::cMenRet := substr(::cMenRet,1,250)
		cauxMenRet	:= '{ "method" : "GET" ,"Status" : "' + ::cMenRet +  '" }'
		::jRetorno := cauxMenRet
	ENDIF

	lRet := oRest:setKeyHeaderResponse("Content-Type", "application/json")

return oRest:setResponse( ::jRetorno )


/*/{Protheus.doc} cCrudPAC::PostcCrudPAC() as json
Metodo Post
@type method
@version 12.1.2310
@author Eduardo Brust
@since 12/10/2023
@return variant, return_um objeto
/*/
method PostcCrudPAC() as json class cCrudPAC
	Local lRet			as logical
	local cauxMenRet	as variant

	::cMenRet	:= ""
	FreeObj(::jRetorno)

	lRet	:= .T.

	::jPath := oRest:getQueryRequest()
	if ( ::jPath <> Nil )
		::cTOKEN	:= ::jPath[ 'token' ]
		if ( valtype(::cTOKEN) == 'U' )
			::cTOKEN := ''
			::cMenRet := "|token invalido|"
			lRet	:= .F.
		endif
	endif

	IF lRet
		::jBody := JsonObject():new()
		::jBody:fromJson( oRest:GetBodyRequest() )

		if ( ::jBody <> Nil )

			//varro o json recebido
			lRet := ::VarreJson("post")
		endif
	ENDIF

	IF empty(::cMenRet)
		::cMenRet := "Registros atualizados com sucesso.!"
	ENDIF

	::cMenRet := substr(::cMenRet,1,250)
	cauxMenRet	:= '{ "method" : "POS" ,"Status" : "' + ::cMenRet +  '" }'
	::jRetorno	:= cauxMenRet

	lRet := oRest:setKeyHeaderResponse("Content-Type", "application/json")

return oRest:setResponse( ::jRetorno )


/*/{Protheus.doc} cCrudPAC::PutcCrudPAC() as json
Metodo Put
@type method
@version 12.1.2310
@author Eduardo Brust
@since 12/10/2023
@return variant, return_um objeto
/*/
method PutcCrudPAC() as json class cCrudPAC
	Local lRet			as logical
	local cauxMenRet	as variant

	::cMenRet	:= ""
	FreeObj(::jRetorno)

	lRet	:= .T.

	::jPath := oRest:getQueryRequest()
	if ( ::jPath <> Nil )
		::cTOKEN	:= ::jPath[ 'token' ]
		if ( valtype(::cTOKEN) == 'U' )
			::cTOKEN := ''
			::cMenRet := "|token invalido|"
			lRet	:= .F.
		endif
	endif

	IF lRet
		::jBody := JsonObject():new()
		::jBody:fromJson( oRest:GetBodyRequest() )

		if ( ::jBody <> Nil )

			//varro o json recebido
			lRet := ::VarreJson("put")
		endif
	ENDIF

	IF empty(::cMenRet)
		::cMenRet := "Registros atualizados com sucesso.!"
	ENDIF

	::cMenRet := substr(::cMenRet,1,250)
	cauxMenRet	:= '{ "method" : "put" ,"Status" : "' + ::cMenRet +  '" }'
	::jRetorno	:= cauxMenRet

	lRet := oRest:setKeyHeaderResponse("Content-Type", "application/json")

return oRest:setResponse( ::jRetorno  )


/*/{Protheus.doc} cCrudPAC::PatchcCrudPAC() as json
Metodo Patch
@type method
@version 12.1.2310
@author Eduardo Brust
@since 12/10/2023
@return variant, return_um objeto
/*/
method PatchcCrudPAC() as json class cCrudPAC

	::jPath := oRest:getPathParamsRequest()
	if ( ::jPath <> Nil )
		::cCodigo := ::jPath[ 'codigo' ]
		if ( valtype(::cCodigo) == 'U' )
			::cCodigo := ''
		endif
	endif

	::cData := '{ "method" : "PATCH" , "codigo" : "' + ::cCodigo + '" '

	::jBody := JsonObject():new()
	::jBody:fromJson( oRest:GetBodyRequest() )
	if ( ::jBody <> Nil )
		if ( !empty(::jBody:GetJsonText("cpo1")) )
			::cData += ', "cpo1" : "' + ::jBody:GetJsonText("cpo1") + '" '
		endif
		if ( !empty(::jBody:GetJsonText("cpo2")) )
			::cData += ', "cpo2" : "' + ::jBody:GetJsonText("cpo2") + '" '
		endif
	endif

	::cData += '}'

return oRest:setResponse( ::cData )


/*/{Protheus.doc} cCrudPAC::DeletecCrudPAC() as json
Metodo Delete
@type method
@version 12.1.2310
@author Eduardo Brust
@since 12/10/2023
@return variant, return_um objeto
/*/
method DeletecCrudPAC() as json class cCrudPAC

	Local lRet			as logical
	local cauxMenRet	as variant

	::cMenRet	:= ""
	FreeObj(::jRetorno)

	lRet	:= .T.

	::jPath := oRest:getQueryRequest()
	if ( ::jPath <> Nil )
		::cTOKEN	:= ::jPath[ 'token' ]
		if ( valtype(::cTOKEN) == 'U' )
			::cTOKEN := ''
			::cMenRet := "|token invalido|"
			lRet	:= .F.
		endif
	endif

	IF lRet
		::jBody := JsonObject():new()
		::jBody:fromJson( oRest:GetBodyRequest() )

		if ( ::jBody <> Nil )

			//varro o json recebido
			lRet := ::VarreJson("delete")
		endif
	ENDIF

	IF empty(::cMenRet)
		::cMenRet := "Registros atualizados com sucesso.!"
	ENDIF

	::cMenRet := substr(::cMenRet,1,250)
	cauxMenRet	:= '{ "method" : "delete" ,"Status" : "' + ::cMenRet +  '" }'
	::jRetorno	:= cauxMenRet

	lRet := oRest:setKeyHeaderResponse("Content-Type", "application/json")

return oRest:setResponse( ::jRetorno  )

/*/{Protheus.doc} cCrudPAC::ConsultaPAC(cPacFil as Character,cPacUsu as Character,cPacCC as Character,cPacProcesso as Character) as json
método para consulta PAC
@type method
@version 12.1.2310
@author Eduardo Brust
@since 12/10/2023
@return json, retorna um json
/*/
method ConsultaPAC(cPacFil as Character,cPacUsu as Character,cPacCC as Character,cPacProcesso as Character) as json class cCrudPAC
	Local cQuery 		:= ""	as Character
	Local cTrb			:= ""	as Character
	Local aData 		:= {}	as array
	Local nPos			:= 0	as numeric
	Local JData					as json
	Local jAux					as json

	//protecao de erro
	DEFAULT cPacFil 		:= ""
	DEFAULT cPacUsu 		:= ""
	DEFAULT cPacCC 			:= ""
	DEFAULT cPacProcesso 	:= ""

	JData := JsonObject():new()

	cQuery += " SELECT PAC_FILIAL, PAC_EMP, PAC_FIL, PAC_USU, PAC_CC, PAC_PROC2, PAC_PROC,PAC_IDORQ " 		   	+ CRLF
	cQuery += " FROM " + RetSqlName("PAC") + " PAC "            + CRLF
	cQuery += " WHERE D_E_L_E_T_ = ' ' "                        + CRLF
	cQuery += " AND PAC_MSBLQL = '2' "                          + CRLF
	cQuery += " AND PAC_FILIAL = '" + FwxFilial("PAC") + "' "   + CRLF
	cQuery += " AND PAC_EMP = '" + cEmpAnt + "' "   			+ CRLF

	IF !EMPTY(cPacFil)
		cQuery += "AND PAC_FIL  = '" + cPacFil + "' "      + CRLF
	ENDIF

	IF !EMPTY(cPacUsu)
		cQuery += "AND PAC_USU  = '" + cPacUsu + "' "      + CRLF
	ENDIF

	IF !EMPTY(cPacCC)
		cQuery += "AND PAC_CC  = '" + cPacCC + "' "      + CRLF
	ENDIF

	IF !EMPTY(cPacProcesso)
		cQuery += "AND PAC_PROC2  = '" + cPacProcesso + "' " + CRLF
	ENDIF

	cTrb := MpSysOpenQuery(cQuery)

	//gravo o resultado da query num arquivo json
	While (cTrb)->(!Eof())
		jAux	:= JsonObject():new()
		Aadd(aData,jAux)

		nPos := Len(aData)
		aData[nPos]['PAC_FIL' ] 	:= (cTrb)->PAC_FIL
		aData[nPos]['PAC_USU' ] 	:= (cTrb)->PAC_USU
		aData[nPos]['PAC_CC' ] 		:= (cTrb)->PAC_CC
		aData[nPos]['PAC_PROC2' ] 	:= (cTrb)->PAC_PROC2
		aData[nPos]['PAC_PROC' ] 	:= (cTrb)->PAC_PROC
		aData[nPos]['PAC_IDORQ' ] 	:= (cTrb)->PAC_IDORQ

		FreeObj(jAux)
		(cTrb)->(DbSkip())
	EndDo

	JData:set(aData)

	//FECHO A AREA ABERTA PELA QUERY
	If Select(cTrb) > 0 .AND. !EMPTY(cTrb)
		(cTrb)->(DbCloseArea())
		cTrb	:= ""
	endif

return JData


/*/{Protheus.doc} cCrudPAC::ValidaQueryString(cPacFil as Character,cPacUsu as Character,cPacCC as Character,cPacProcesso as Character) as Logical
Valida se os parametros passados para a API estão consistentes.
@type method
@version 12.1.2310
@author Eduardo Brust
@since 22/06/2023
@return logical, return .T. OR .F.
/*/
method ValidaQueryString(cPacFil as Character,cPacUsu as Character,cPacCC as Character,cPacProcesso as Character) as Logical class cCrudPAC
	Local lRet	:= .T.
	Local nQtd	:= 4  	//indica qts parametros foram passados para a API
	Local nMin	:= 2	//indica a qtd minima de parametros que a API precisa receber para não degradar consulta ao banco

	//protecao de erro
	DEFAULT cPacFil 		:= ""
	DEFAULT cPacUsu 		:= ""
	DEFAULT cPacCC 			:= ""
	DEFAULT cPacProcesso 	:= ""

	//logica para validacao dos parametros

	if empty(::cTOKEN)
		::cMenRet += "| token não informado! "
		lRet	:= .F.
	else
		if empty(cPacFil)
			nQtd--
			::cMenRet += "| PacFil não informada! "
		endif

		if empty(cPacUsu)
			nQtd--
			::cMenRet += "| PacUsu não informado! "
		endif

		if empty(cPacCC)
			nQtd--
			::cMenRet += "| PacCC não informado! "
		endif

		if empty(cPacProcesso)
			nQtd--
			::cMenRet += "| PacProcesso não informado! "
		else
			nMin++  //cPacProcesso informado. aumento o nr minimo de parametros pois este campo não faz parte da chave no banco de dados. Evita sobrecarga no banco.
		endif

		//validacao minima de parametros
		if nQtd < nMin
			::cMenRet += "| QTd minima de parametros não informados! "
			lRet	:= .F.
		endif
	endif

return lRet


/*/{Protheus.doc} cCrudPAC::ConsultaCentroCusto(cPacFil as Character,cPacCC as Character) as Character
Consulta informacao de centro de custo 
@type method
@version 12.1.2310
@author Eduardo Brust
@since 22/06/2023
@return variant, retorna o centro de custo
/*/
method ConsultaCentroCusto(cPacFil as Character,cPacCC as Character) as Character class cCrudPAC
	Local cQuery        := ""	as character
	Local cTrb			:= ""	as Character
	Local aBindParam    := {} 	as array
	Local cDataCC				as Character
	Local cDescCC		:= ""	as character

	//protecao de erro
	DEFAULT cPacFil 		:= ""
	DEFAULT cPacCC 			:= ""

	If EMPTY(cPacCC)
		aBindParam := {DTOS(::dDataExec),SubStr(cPacFil,1,4)}
		cQuery := ""
		cQuery += " SELECT CTT_CUSTO,CTT_DESC01,CTT_DTEXSF FROM ( "   +CRLF
		cQuery += " 	SELECT CTT_CUSTO,CTT_DESC01,CTT_DTEXSF    "   +CRLF
		cQuery += " 	FROM "+RetSqlName("CTT")+"  CTT 			" +CRLF
		cQuery += " 	WHERE CTT.D_E_L_E_T_ = ' ' 					" +CRLF
		cQuery += " 	  	AND CTT_BLOQ = '2'       				" +CRLF
		cQuery += "   		AND CTT_CLASSE = '2'					" +CRLF
		cQuery += "  		AND CTT_DTEXSF >= ?       				" +CRLF
		cQuery += "   		AND CTT_FILIAL = ? 						" +CRLF
		cQuery += " ORDER BY CTT.CTT_CUSTO) A WHERE rownum = 1		" +CRLF

		cTrb := MPSysOpenQuery(cQuery,,,,aBindParam)

		If !(cTrb)->(Eof())
			cPacCC 	:=	(cTrb)->CTT_CUSTO
			cDescCC	:=	(cTrb)->CTT_DESC01
			cDataCC	:=	(cTrb)->CTT_DTEXSF
		Endif

	Endif

	//FECHO A AREA ABERTA PELA QUERY
	If Select(cTrb) > 0 .AND. !EMPTY(cTrb)
		(cTrb)->(DbCloseArea())
		cTrb	:= ""
	endif

	//indica que a query anterior de centro de custo não foi rodada. podendo rodar esta query
	if empty(cDescCC)

		aBindParam := {SubStr(cPacFil,1,4),cPacCC}
		cQuery := " "
		cQuery += " SELECT CTT_DESC01,CTT_DTEXSF  "					+CRLF
		cQuery += " FROM "+RetSqlName("CTT")+"  CTT " 				+CRLF
		cQuery += " WHERE CTT.D_E_L_E_T_ = ' ' " 					+CRLF
		cQuery += "   AND CTT_BLOQ = '2'       " 					+CRLF
		cQuery += "   AND CTT_FILIAL = ? 						"   +CRLF
		cQuery += "   AND CTT_CUSTO = ? 						"   +CRLF

		cTrb := MPSysOpenQuery(cQuery,,,,aBindParam)

		If !(cTrb)->(Eof())
			cDescCC	:=	(cTrb)->CTT_DESC01
			cDataCC	:=	(cTrb)->CTT_DTEXSF
		Endif

		//FECHO A AREA ABERTA PELA QUERY
		If Select(cTrb) > 0 .AND. !EMPTY(cTrb)
			(cTrb)->(DbCloseArea())
			cTrb	:= ""
		endif
	endif

	//valido situacao do centro de custo
	if empty(cDescCC) .OR. cDataCC < dtos(::dDataExec)
		lErro       := .F.
		if !("|problema no cadastro de centro de custo no protheus|" $ ::cMenRet)
			::cMenRet	+= "|problema no cadastro de centro de custo no protheus|"
		endif
		cPacCC	:= ""
	endif

return cPacCC


/*/{Protheus.doc} cCrudPAC::VarreJson(cmetodo as Character)	as logical
Varro o Json recebido no body
@type method
@version 12.1.2310
@author Eduardo Brust
@since 23/06/2023
@return logical, return .T. OR .F.
/*/
method VarreJson(cmetodo as Character)	as logical  class cCrudPAC
	Local lRetP 		as logical 		//verifico se propriedade informada existe
	Local lRet			as logical
	local lErro			as logical
	local cGravaCabec	as character
	Local cGravaItem	as character	//usado para montar o conteudo do json dinamicamente
	Local jGravaItem	as json
	Local i				as numeric
	Local nTotItem		as numeric
	Local cCusto		as character

	//protecao de erro
	default cmetodo	:= ""

	lErro	:= .F.

	cGravaCabec  := '{'

	lRetP	:= ::jBody:HasProperty("nIdOrq")
	if lRetP .AND. !lErro
		IF VAL(::jBody:GetJsonText("nIdOrq")) > 0
			cGravaCabec += ' "nIdOrq" : ' + ::jBody:GetJsonText("nIdOrq")
		ELSE
			::cMenRet += "|nIdOrq invalido|"
			lErro	:= .T.
		ENDIF
	endif

	lRetP	:= ::jBody:HasProperty("cOqUsr")
	if lRetP .AND. !lErro
		IF !EMPTY(::jBody:GetJsonText("cOqUsr"))
			cGravaCabec += ', "cOqUsr" : "' + ::jBody:GetJsonText("cOqUsr") + '"'
		ELSE
			::cMenRet += "|cOqUsr invalido|"
			lErro	:= .T.
		ENDIF
	endif

	lRetP	:= ::jBody:HasProperty("aItem")

	if lRetP .AND. !lErro
		nTotItem	:= len(::jBody["aItem"]) - 1  //orquestra manda um par de chaves a mais no json
		for i:= 1 to nTotItem

			cGravaItem := ""
			lErro	:= .F.

			lRetP	:= ::jBody["aItem"][i]:HasProperty("cOqTpAtu")
			if lRetP .AND. !lErro
				IF !EMPTY(::jBody["aItem"][i]:GetJsonText("cOqTpAtu"))
					cGravaItem += ', "cOqTpAtu" : "' + ::jBody["aItem"][i]:GetJsonText("cOqTpAtu") + '"'
				ELSE
					::cMenRet += alltrim(cvaltochar(I)) + "|cOqTpAtu invalido|"
					lErro	:= .T.
				ENDIF
			else
				lErro	:= .T.
			endif

			lRetP	:= ::jBody["aItem"][i]:HasProperty("cOqFilial")
			if lRetP .AND. !lErro
				IF !EMPTY(::jBody["aItem"][i]:GetJsonText("cOqFilial"))
					cGravaItem += ', "cOqFilial" : "' + ::jBody["aItem"][i]:GetJsonText("cOqFilial") + '"'
				ELSE
					::cMenRet += alltrim(cvaltochar(I)) + "|cOqFilial invalido|"
					lErro	:= .T.
				ENDIF
			else
				lErro	:= .T.
			endif

			lRetP	:= ::jBody["aItem"][i]:HasProperty("cOqCC")
			if lRetP .AND. !lErro
				cCusto	:=	::ConsultaCentroCusto(::jBody["aItem"][i]:GetJsonText("cOqFilial"),::jBody["aItem"][i]:GetJsonText("cOqCC"))
				if !empty(cCusto)
					cGravaItem += ', "cOqCC" : "' +  cCusto + '"'
				else
					::cMenRet += alltrim(cvaltochar(I)) + "|cOqCC invalido|"
					lErro	:= .T.
				endif
			else
				lErro	:= .T.
			endif

			lRetP	:= ::jBody["aItem"][i]:HasProperty("cOqProc")
			if lRetP .AND. !lErro
				IF !EMPTY(::jBody["aItem"][i]:GetJsonText("cOqProc"))
					cGravaItem += ', "cOqProc" : "' + ::jBody["aItem"][i]:GetJsonText("cOqProc") + '"'
				ELSE
					::cMenRet += alltrim(cvaltochar(I)) + "|cOqProc invalido|"
					lErro	:= .T.
				ENDIF
			else
				lErro	:= .T.
			endif

			lRetP	:= ::jBody["aItem"][i]:HasProperty("cOqProc2")
			if lRetP .AND. !lErro
				IF !EMPTY(::jBody["aItem"][i]:GetJsonText("cOqProc2"))
					cGravaItem += ', "cOqProc2" : "' + ::jBody["aItem"][i]:GetJsonText("cOqProc2") + '"'
				ELSE
					::cMenRet += alltrim(cvaltochar(I)) + "|cOqProc2 invalido|"
					lErro	:= .T.
				ENDIF
			else
				lErro	:= .T.
			endif

			cGravaItem	+= ' }'

			if !lErro
				jGravaItem := JsonObject():New()
				jGravaItem:fromJson(cGravaCabec + cGravaItem)

				//chamo metodo para gravar o item na pac
				if lower(cmetodo) == "post"
					if !::GravaPAC(jGravaItem)
						lErro := .T.
					endif
				endif

				//chamo metodo para atualizar o item na pac
				if lower(cmetodo) == "put"
					if !::AtualizaPAC(lower(cmetodo),jGravaItem)
						lErro := .T.
					endif
				endif

				//chamo metodo para atualizar o item na pac
				if lower(cmetodo) == "delete"
					if !::AtualizaPAC(lower(cmetodo),jGravaItem)
						lErro := .T.
					endif
				endif
			endif

			FreeObj(jGravaItem)
		next
	else
		::cMenRet += "|Json não reconhecido.|"
		lErro	:= .T.
	endif

	lret := !lErro

return lret


/*/{Protheus.doc} cCrudPAC::GravaPAC(jGravaItem as json) as logical
Grava registros na tabela PAC
@type method
@version 12.1.2310
@author Eduardo Brust
@since 23/06/2023
@return logical, return .T. OR .F.
/*/
method GravaPAC(jGravaItem as json) as logical class cCrudPAC
	Local lret 		:= .T.	as logical
	Local lachou	:= .F. 	as logical
	local cLogPAC	:= ""	as character
	local lRetP				as logical
	local cChave	:= ""	as character

	//protecao de erro
	DEFAULT	jGravaItem	:= nil

	lRetP	:= jGravaItem:HasProperty("nIdOrq")

	if lRetP

		if !empty(jGravaItem:GetJsonText("cOqFilial")) .and. !empty(jGravaItem:GetJsonText("cOqUsr")) .and. !empty(jGravaItem:GetJsonText("cOqCC")) .and. !empty(jGravaItem:GetJsonText("cOqProc2"))

			cChave	:= jGravaItem:GetJsonText("cOqFilial")+jGravaItem:GetJsonText("cOqUsr")+jGravaItem:GetJsonText("cOqCC")+jGravaItem:GetJsonText("cOqProc2")

			lAchou :=	::ChavePAC(jGravaItem:GetJsonText("cOqFilial"),jGravaItem:GetJsonText("cOqUsr"),jGravaItem:GetJsonText("cOqCC"),jGravaItem:GetJsonText("cOqProc2"))

			IF lAchou

				lRet := ::AtualizaPAC("post",jGravaItem)

			ELSE

				cLogPAC 	:=	"||Incluido por IdOrq: " + cvaltochar(jGravaItem:GetJsonText("nIdOrq")) + " Data:"+DTOC(::dDataExec)+" || Hora:"+Time()+" ||"

				DBSELECTAREA("PAC")

				PAC->(RecLock("PAC",.T.))

				PAC->PAC_FILIAL := XFILIAL("PAC")
				PAC->PAC_EMP    := cEmpAnt
				PAC->PAC_FIL	:= jGravaItem:GetJsonText("cOqFilial")
				PAC->PAC_USU    := jGravaItem:GetJsonText("cOqUsr")
				PAC->PAC_CC     := jGravaItem:GetJsonText("cOqCC")
				PAC->PAC_PROC2  := jGravaItem:GetJsonText("cOqProc2")
				PAC->PAC_PROC	:= jGravaItem:GetJsonText("cOqProc")
				PAC->PAC_IDORQ	:= val(jGravaItem:GetJsonText("nIdOrq"))
				PAC->PAC_LOG    := SubStr(ALLTRIM(cLogPAC),1,200)
				PAC->PAC_MSBLQL := "2"

				PAC->(MsUnlock())

				IF PAC->PAC_IDORQ <> val(jGravaItem:GetJsonText("nIdOrq"))
					::cMenRet += "||Erro ao inclur registro./" + cChave
					lRet := .F.
				ENDIF
			ENDIF
		else
			IF !("|Falta de parametros para inclusao/alteracao de registro|" $ ::cMenRet)
				::cMenRet += "|Falta de parametros para inclusao/alteracao de registro|"
			ENDIF
			lRet := .F.
		endif
	endif

	FreeObj(jGravaItem)

return lRet


/*/{Protheus.doc} cCrudPAC::ChavePAC(cPacFil as Character,cPacUsu as Character,cPacCC as Character,cPacProcesso as Character) as Logical
Consulta chave da PAC
@type method
@version 12.1.2310
@author Eduardo Brust
@since 12/10/2023
@return logical, return .T. OR .F.
/*/
method ChavePAC(cPacFil as Character,cPacUsu as Character,cPacCC as Character,cPacProcesso as Character) as Logical class cCrudPAC
	Local lret 			:= .F.	as logical
	Local cQuery        := ""	as character
	Local cTrb			:= ""	as Character
	Local aBindParam    := {} 	as array

	//protecao de erro
	default cPacFil			:= ""
	default cPacUsu			:= ""
	default cPacCC			:= ""
	default cPacProcesso	:= ""

	aBindParam := {"2",FwxFilial("PAC"),cEmpAnt,alltrim(cPacFil),alltrim(cPacUsu),alltrim(cPacCC),alltrim(cPacProcesso)}
	cQuery := " "
	cQuery += " SELECT COUNT(*) CHAVE " 		   		+ CRLF
	cQuery += " FROM " + RetSqlName("PAC") + " PAC "    + CRLF
	cQuery += " WHERE D_E_L_E_T_ = ' ' "                + CRLF
	cQuery += " AND PAC_MSBLQL = ? "                    + CRLF
	cQuery += " AND PAC_FILIAL = ?"		 		   		+ CRLF
	cQuery += " AND PAC_EMP = ?" 		   				+ CRLF
	cQuery += " AND PAC_FIL  = ?" 		   				+ CRLF
	cQuery += " AND PAC_USU  = ?" 		   				+ CRLF
	cQuery += " AND PAC_CC  = ?" 		   				+ CRLF
	cQuery += " AND PAC_PROC2  = ?" 		   			+ CRLF


	cTrb := MPSysOpenQuery(cQuery,,,,aBindParam)

	If !(cTrb)->(Eof())

		IF 	(cTrb)->CHAVE >  0
			lret	:= .T.
		ENDIF

	Endif

	//FECHO A AREA ABERTA PELA QUERY
	If Select(cTrb) > 0 .AND. !EMPTY(cTrb)
		(cTrb)->(DbCloseArea())
		cTrb	:= ""
	endif


return lRet


/*/{Protheus.doc} cCrudPAC::AtualizaPAC(cmetodo as Character,jGravaItem as json)	as logical
Atualiza tabela PAC
@type method
@version 12.1.2310
@author Eduardo Brust
@since 25/06/2023
@return logical, return .T. OR .F.
/*/
method AtualizaPAC(cmetodo as Character,jGravaItem as json)	as logical class cCrudPAC
	Local lret 		:= .T.	as logical
	local cLogPAC	:= ""	as character
	local lRetP				as logical
	Local cUpdate	:= ""	as character
	local nStatus	:=	0	as numeric

	//protecao de erro
	DEFAULT	cmetodo		:= ""
	DEFAULT	jGravaItem	:= nil

	lRetP	:= jGravaItem:HasProperty("nIdOrq")

	if lRetP

		if lower(cmetodo) == "delete"

			cLogPAC :=	"|Bloqueado/Deletado por IdOrq: " + cvaltochar(jGravaItem:GetJsonText("nIdOrq")) + " Data:"+DTOC(::dDataExec)+" || Hora:"+Time()+" |"

			cUpdate := ""
			cUpdate += " UPDATE " + RETSQLNAME("PAC") + " SET PAC_IDORQ = " + cvaltochar(jGravaItem:GetJsonText("nIdOrq")) + "," + CRLF
			cUpdate += " PAC_MSBLQL = '1', D_E_L_E_T_ = '*', R_E_C_D_E_L_ = R_E_C_N_O_ "    + "," + CRLF
			cUpdate += " PAC_LOG  = '" + SubStr(ALLTRIM(cLogPAC),1,200)						+ "'" + CRLF
		else
			cLogPAC 	:=	"|Alterado por IdOrq: " + cvaltochar(jGravaItem:GetJsonText("nIdOrq")) + " Data:"+DTOC(::dDataExec)+" || Hora:"+Time()+" |"

			cUpdate := ""
			cUpdate += " UPDATE " + RETSQLNAME("PAC") + " SET PAC_IDORQ = " + cvaltochar(jGravaItem:GetJsonText("nIdOrq")) + "," + CRLF
			cUpdate += " PAC_PROC = '" + jGravaItem:GetJsonText("cOqProc") 				    + "' ," + CRLF
			cUpdate += " PAC_LOG  = '" + SubStr(ALLTRIM(cLogPAC),1,200)						+ "'" 	+ CRLF
		endif

		cUpdate += " WHERE D_E_L_E_T_ = ' ' "                									+ CRLF
		cUpdate += " AND PAC_MSBLQL = '2' "                          							+ CRLF
		cUpdate += " AND PAC_FILIAL = '" + XFILIAL("PAC")								+ "'"	+ CRLF
		cUpdate += " AND PAC_EMP = '" + cEmpAnt											+ "'"	+ CRLF
		cUpdate += " AND PAC_FIL  = '" + ALLTRIM(jGravaItem:GetJsonText("cOqFilial") )	+ "'" 	+ CRLF
		cUpdate += " AND PAC_USU  = '" + ALLTRIM(jGravaItem:GetJsonText("cOqUsr")) 		+ "'" 	+ CRLF
		cUpdate += " AND PAC_CC  = '" + ALLTRIM(jGravaItem:GetJsonText("cOqCC")) 		+ "'" 	+ CRLF
		cUpdate += " AND PAC_PROC2  = '" + ALLTRIM(jGravaItem:GetJsonText("cOqProc2")) 	+ "'" 	+ CRLF

		nStatus := TCSQLExec(cUpdate)

		if (nStatus < 0)
			::cMenRet += "||Erro ao atualizar registro./"
			lRet := .F.
		endif
	endif

return lRet

/*

https://tdn.totvs.com/display/tec/Reflection+e+Annotation

1. GET:
   - 200 (OK): A solicitação foi bem-sucedida e o corpo da resposta contém os dados solicitados.
   - 404 (Not Found): O recurso solicitado não foi encontrado.

2. POST:
   - 201 (Created): A solicitação foi bem-sucedida e um novo recurso foi criado.
   - 400 (Bad Request): A solicitação não pôde ser entendida ou contém parâmetros inválidos.
   - 409 (Conflict): O servidor detectou um conflito durante o processamento da solicitação, como um conflito de duplicação de recursos.

3. PUT:
   - 200 (OK): A solicitação foi bem-sucedida e o recurso foi atualizado.
   - 400 (Bad Request): A solicitação não pôde ser entendida ou contém parâmetros inválidos.
   - 404 (Not Found): O recurso a ser atualizado não foi encontrado.

4. PATCH:
   - 200 (OK): A solicitação foi bem-sucedida e o recurso foi atualizado.
   - 400 (Bad Request): A solicitação não pôde ser entendida ou contém parâmetros inválidos.
   - 404 (Not Found): O recurso a ser atualizado não foi encontrado.

5. DELETE:
   - 204 (No Content): A solicitação foi bem-sucedida e o recurso foi excluído.
   - 404 (Not Found): O recurso a ser excluído não foi encontrado.

*/
